# 简介

## 1、 配置
应用的所有事件广播配置选项都存放在 `config/broadcasting.php` 配置文件中。Laravel 开箱支持多种广播驱动：`Pusher`、`Redis`以及一个服务于本地开发和调试的 `log` 驱动。此外，还提供了一个 `null` 驱动用于完全禁止事件广播。每一个驱动在 `config/broadcasting.php` 配置文件中都有一个配置示例。  

## 2、 广播服务提供者
在广播任意事件之前，首先需要注册`App\Providers\BroadcastServiceProvider`。在新安装的 Laravel 应用中，你只需要取消 `config/app.php` 配置文件中 `providers` 数组内对应服务提供者之前的注释即可。该提供者允许你注册广播授权路由和回调。  

## 3、 CSRF令牌
[Laravel Echo](https://laravelacademy.org/post/8379.html#toc_17)需要访问当前 Session 的 CSRF 令牌（token），如果有效的话，Echo 将会从 JavaScript 变量`Laravel.csrfToken` 中获取令牌。如果你运行过 Artisan 命令make:auth 的话，该对象定义在 `resources/views/layouts/app.blade.php` 布局文件中。如果你没有使用这个布局，你可以在应用的 HTML 元素 `head` 中定义这样一个 `meta` 标签：  
```htm
<meta name="csrf-token" content="{{ csrf_token() }}">
```

## 4、 驱动
### \# [Pusher](https://pusher.com/)
如果你准备通过 Pusher 广播事件，需要使用 Composer 包管理器安装对应的 Pusher PHP SDK：  
```
composer require pusher/pusher-php-server "~3.0"
```
接下来，你需要在 `config/broadcasting.php` 配置文件中配置你的 Pusher 证书。一个配置好的 Pusher 示例已经包含在这个文件中，你可以按照这个模板进行修改，指定自己的 Pusher key、secret 和应用 ID 即可。`config/broadcasting.php` 文件的 `pusher` 配置还允许你指定额外的被 Pusher 支持的 `options`，例如 cluster：  
```php
'options' => [
    'cluster' => 'eu',
    'encrypted' => true
], 
```
使用 Pusher 和 Laravel Echo 的时候，需要在 `resources/assets/js/bootstrap.js` 文件中安装某个 Echo 实例的时候指定 `pusher` 作为期望的广播：  
```js
import Echo from "laravel-echo"

window.Pusher = require('pusher-js');

window.Echo = new Echo({
    broadcaster: 'pusher',
    key: 'your-pusher-key'
});
```

### \# Redis
如果你使用 Redis 广播，需要安装 Predis 库：
```
composer require predis/predis
```
Redis 广播使用 Redis 的`发布/订阅功能`进行广播；不过，你需要将其和能够接受 Redis 消息的 Websocket 服务器进行配对以便将消息广播到 Websocket 频道。  

当 Redis 广播发布事件时，事件将会被发布到指定的频道上，传递的数据是一个 JSON 格式的字符串，其中包含了事件名称、数据明细 `data`、以及生成事件socket ID 的用户。  

**Socket.IO**  
如果你想配对 Redis 广播和 Socket.IO 服务器，则需要在应用的 HTML 元素 `head` 中引入 Socket.IO JavaScript 库。当 Socket.IO 服务器启动后，会自动通过一个标准的 URL 来暴露客户端 JavaScript 库，例如，如果你在同一个域名下运行 Socket.IO 和 Web 应用，可以这样访问客户端 JavaScript 库：  
```
<script src="//{{ Request::getHost() }}:6001/socket.io/socket.io.js"></script>
```
接下来，你需要使用 socket.io 连接器和 host 来实例化 Echo：  
```js
import Echo from "laravel-echo"

window.Echo = new Echo({
    broadcaster: 'socket.io',
    host: window.location.hostname + ':6001'
});
```
最后，需要运行一个与之兼容的 Socket.IO 服务器。Laravel 并未内置一个 Socket.IO 服务器实现，不过，这里有一个第三方实现的 Socket.IO 驱动：`tlaverdure/laravel-echo-server`。  

## 5、 队列预备知识
在开始介绍广播事件之前，还需要配置并运行一个[队列监听器](https://laravelacademy.org/post/8369.html)。所有事件广播都通过队列任务来完成以便应用的响应时间不受影响。  




# 概念概览
## 1、 示例应用
在深入了解每个事件广播组件之前，让我们先通过一个电商网站作为示例对整体有个大致的了解。这里我们不会讨论 `Pusher` 和 `Laravel Echo` 的配置细节，这些将会放在本文档的后续部分进行讨论。  

在我们的应用中，假设我们有一个页面允许用户查看订单的物流状态，我们还假设当应用进行订单状态更新处理时会触发一个 `ShippingStatusUpdated` 事件：  
```
event(new ShippingStatusUpdated($update));
```

## 2、 ShouldBroadcast接口
当用户查看某个订单时，我们不希望他们必须刷新页面来查看更新状态。取而代之地，我们希望在创建时将更新广播到应用。因此，我们需要标记`ShippingStatusUpdated` 事件实现 `ShouldBroadcast` 接口，这样，Laravel 就会在触发事件时广播该事件：  
```php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;

class ShippingStatusUpdated implements ShouldBroadcast
{
    /**
     * 物流状态更新信息.
     *
     * @var string
     */
    public $update;
}
```
`ShouldBroadcast` 接口要求事件类定义一个 `broadcastOn` 方法，该方法会返回事件将要广播的频道。事件类生成时一个空的方法存根已经定义，我们所要做的只是填充其细节。我们只想要订单的创建者才能够察看状态更新，所以我们将这个事件广播在一个与订单绑定的私有频道上：  
```php
/**
 * 获取事件广播的频道.
 *
 * @return array
 */
public function broadcastOn()
{
    return new PrivateChannel('order.'.$this->update->order_id);
}
```

## 3、 授权频道
记住，用户必须经过授权之后才能监听私有频道。我们可以在 `routes/channels.php` 文件中定义频道授权规则。在本例中，我们需要验证任意试图监听`order.1` 频道的用户确实是订单的创建者：  
```php
Broadcast::channel('order.{$orderId}', function ($user, $orderId) {
    return $user->id === Order::findOrNew($orderId)->user_id;
});
```
`channel`方法接收两个参数：频道的名称以及返回 `true` 或 `false` 以表明用户是否被授权可以监听频道的回调。  

所有授权回调都接收当前认证用户作为第一个参数以及任意额外通配符参数作为随后参数，在本例中，我们使用 `{orderId}` 占位符标识频道名称的ID部分是一个通配符。  

## 4、 监听事件广播
接下来要做的就是在 JavaScript 中监听事件。我们可以使用 Laravel Echo 来完成这一工作。首先，我们使用 `private` 方法订阅到私有频道。然后，我们使用`listen` 方法监听 `ShippingStatusUpdated` 事件。默认情况下，所有事件的公共属性都会包含在广播事件中：  
```js
Echo.private('order.${orderId}')
    .listen('ShippingStatusUpdated', (e) => {
        console.log(e.update);
    });
```




# 定义广播事件
要告诉 Laravel 给定事件应该被广播，需要在事件类上实现 `Illuminate\Contracts\Broadcasting\ShouldBroadcast` 接口。  

`ShouldBroadcast` 接口要求你实现一个方法：`broadcastOn`。该方法应该返回一个事件广播频道或频道数组。这些频道必须是 `Channel`、`PrivateChannel` 或 `PresenceChannel` 的实例，`Channel` 频道表示任意用户都可以订阅的公共频道，而 `PrivateChannels` 或 `PresenceChannels` 则代表需要进行频道授权的私有频道：  
```php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Queue\SerializesModels;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;

class ServerCreated implements ShouldBroadcast
{
    use SerializesModels;

    public $user;

    /**
     * 创建一个新的事件实例.
     *
     * @return void
     * @translator laravelacademy.org
     */
    public function __construct(User $user)
    {
        $this->user = $user;
    }

    /**
     * 获取事件广播的频道.
     *
     * @return Channel|array
     */
    public function broadcastOn()
    {
        return new PrivateChannel('user.'.$this->user->id);
    }
}
```
然后，你只需要正常[触发这个事件](https://laravelacademy.org/post/8355.html)即可。一旦事件被触发，[队列任务](https://laravelacademy.org/post/8369.html)会自动通过指定广播驱动广播该事件。  

## 1、 广播名称
默认情况下，Laravel 会使用事件的类名来广播事件，不过，你可以通过在事件中定义 `broadcastAs` 方法来自定义广播名称：  
```php
/**
 * 事件的广播名称.
 *
 * @return string
 */
public function broadcastAs()
{
    return 'server.created';
}
```
如果你使用了 `broadcastAs` 方法来广播事件，需要确保在注册监听器的时候带上了 `.` 前缀字符。这将会告知 Echo 不要在事件之前添加应用的命名空间：  
```
.listen('.server.created', function (e) {
    ....
});
```

## 2、 广播数据
如果某个事件被广播，其所有的 `public` 属性都会按照事件负载（payload）自动序列化和广播，从而允许你从 JavaScript 中访问所有 `public` 数据，举个例子，如果你的事件有一个单独的包含 Eloquent 模型的 `$user` 属性，广播负载定义如下：  
```
{
    "user": {
        "id": 1,
        "name": "Patrick Stewart"
        ...
    }
}
```
不过，如果你希望对广播负载有更加细粒度的控制，可以添加 `broadcastWith` 方法到事件，该方法会返回你想要通过事件广播的数组数据：  
```php
/**
 * 获取广播数据
 *
 * @return array
 */
public function broadcastWith(){
    return ['id' => $this->user->id];
}
```

## 3、 广播队列
默认情况下，每个广播事件都会被推送到配置文件 `queue.php` 中指定的默认队列连接对应的默认队列中，你可以通过在事件类上定义一个 `broadcastQueue` 属性来自定义广播使用的队列。该属性需要指定广播时你想要使用的队列名称：  
```php
/**
 * 事件被推送的队列名称.
 *
 * @var string
 */
public $broadcastQueue = 'your-queue-name';
```
如果你想要使用 `sync` 队列而不是默认的队列驱动来广播事件，可以实现` ShouldBroadcastNow` 接口来取代 `ShouldBroadcast`：  
```
<?php

use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;

class ShippingStatusUpdated implements ShouldBroadcastNow
{
    //
}
```

## 4、 广播条件
有时候你想要在指定条件为 `true` 的前提下才广播事件，可以通过添加 `broadcastWhen` 方法到事件类来定义这些条件：  
```php
/**
 * 判定事件是否广播
 *
 * @return bool
 */
public function broadcastWhen()
{
    return $this->value > 100;
}    
```




# 授权频道

