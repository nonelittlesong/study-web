
## 基本数据类型
基本： undefined, null, boolean, number, string  
复杂： object  
## 字符串
1. 转数字：  
   Number(), parseInt(), parseFloat()  
2. 转字符串：  
   toString(), String()  
3. 长度：  
   .length  
## 赋值
```js
var myObject = preferredObject || backupObject
```
利用逻辑或的特性，在变量赋值时提供备用值，避免将null或undefined赋值给变量。  

## 引用类型
### 1. Object类型
**创建Object实例有两种方式:**  
第一种：
```js
var person = new Object();
person.name = "Nico";
person.age = 29;
```
第二种：
```js
// 不会调用Object的构造函数
var person = {
  name : "Nico",
  age : 29,
  5: true
}
// 可以用对象字面量封装可选参数
```
**访问对象属性的两种方式：**
```
1. person["name"];
2. person.name;
// 方括号方法的优点是可以使用变量访问属性
var propertyName = "name";
person[propertyName];
```
### 2. Array类型
**创建数组：**  
```js
// 方式1
var colors = new Array();
var colors = new Array(20); // 创建有20个项的数组
var colors = new Array("red", "blue");
// 方式2 不会调用构造函数
var colors = [];
var colors = ["red", "bule"];
// 访问和设置数组
// 索引小于数组长度会修改， 大于会新增
colors[2] = "yellow" // 新增第3项
// 数组长度
colors.length // 可写
```
**检测数组：**  
```js
value instanceof Array;
Array.isArray(value);
```
**转换方法**  
```
var colors = ["red", "blue"];
alert(colors.toString()); // red,blue
alert(colors.valueOf()); // red,blue
alert(colors); // red,blue 后台会调用toString()
```
* toLocaleString()调用每一项的toLocaleString(), 然后用“,“拼接。  
* toString（）调用每一项的toString()。  
* colors.join("×××"), 替换拼接符号。  

**栈方法**  
* push(...) 输入任意项参数，返回更新后元素的个数。  
* pop() 返回栈顶元素。  
* 可以与其他数组方法混合使用。  

**队列方法**  
* shift() 删除队首并返回队首元素。  
* unshift(...) 队首添加任意项，返回新数组长度。  

**正确使用栈和队列**  
1. push + pop = 栈
2. push + shift = 队列
3. unshift + pop = 反向队列
4. unshift + shift = 反向栈

**重排序方法**  
* reverse() 反转。  
* sort() 升序排列。根据toString()比较字符串大小。  

```js
// sort()可以接受一个比较函数
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    }
    else if (value1 > value2) {
        return 1;
    }
    else {
        return 0;
    }
}
var values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); // 0,1,5,10,15
```
**操作方法**  
* concat(...) 基于当前数组，在末尾添加n项，形成一个新数组。（非变异）  
* slice() 接受1/2个参数。（非变异）  
  1个参数： 基于起始位置到数组末尾，创建一个新数组  
  2个参数： 基于起始位置到结束位置（不包括结束位置），创建一个新的数组  
  **参数为负数： 正参数=负参数+数组长度**  
  起始位置大于结束位置： 返回空数组  
* splice(起始位, 删除数, 添加项)  
  * 删除 - (起始位, 删除数)
  * 插入 - (起始位, 0, 添加项...)
  * 替换 - (起始位, 删除数, 添加项...)


**位置方法**  
indexOf(目标, 起始位~可选), lastIndexOf(目标, 起始位~可选)  
通过===查找  

**迭代方法**  

| 方法名 | 作用 |
| ------ | ------ |
| every() | 对数组的每一项给定函数，如果该函数对每一项都返回true，则返回true。 |
| filter() | 对数组的每一项运行给定函数，该函数返回true的项组成的数组。 |
| forEach（） | 对数组的每一项运行给定函数，该函数没有返回值。 |
| map() | 对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组。 |
| some() | 对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 |

**以上方法都不会修改数组中的值。**  
每个方法都接受两个参数：  
* 要在每一项上运行的函数。参数： value, index, array。  
* 运行该函数的作用域对象---影响this的值。  


**缩小方法**  
reduce() 和 reduceRught()  
```
var values = [1, 2, 3, 4, 5];
var sum = values.reduce(function(prev, cur, index, array) {
    return prev + cur;
});
alert(sum); // 15
```

### 3. Date类型
定义：  
```js
var now = new Date();  
/**
 * Date.parse()
 * 支持的日期格式：
 * 6/13/2004
 * January 12, 2004
 * Tue May 25 2004 00:00:00 GMT-0700
 * 2004-05-25T00:00:00
 *
 * 格式错误， 返回NaN
 */
var someDate = new Date(Date.parse("May 25, 2004"));
var someDate = new Date("May 25, 2004"); // 与上一句等价
/**
 * Date.UTC()
 * @param year 年份(必需)
 * @param month 基于0的月份(必需)
 * @param day 月份中的哪一天（1到31)
 * @param hour 小时(以下参数默认为0)
 * @param minute 分钟
 * @param second 秒
 * @param ms 毫秒
 */
var y2k = new Date(Date.UTC(2000, 0));
var y2k = new Date(2000, 0); // 基于系统的本地时区
// 使用+把Date转为String
var start = +new Date();
```
**继承的方法**  
toLocaleString(), toString(), valueOf()  
valueOf()返回Date的毫秒值，可用来比较Date大小。  

**日期格式化方法**  
toDateString(), toTimeString(), toLocaleDateString(), toLocaleTimeString(), 
toUTCString()  

**日期/时间组件方法**  
直接取得和设Date中的待定部分。  

### 4. RegExp类型
定义：  
```js

var expression = / pattern / flags ;
```
flags:  
1. g 全局模式（global），即模式将被应用于所有的字符串，而非在发现第一个匹配项时立即停止。
2. i 不区分大小写（case-insensitive）。
3. m 多行模式（multiline），即达到一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

元字符：  
( \[ { \ ^ | ) ? * + . ] }  

使用RegExp构造函数创建正则表达式：  
```js
var pattern1 = /[bc]at/i;
var pattern2 = new RegExp("[bc]at", "i");
```

ECMAScript5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例。  

**RegExp实例属性**  
1. global 布尔值，是否设置了g
1. ignoreCase 布尔值，是否设置了i
1. multiline 布尔值，是否设置了m
1. lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从0开始算起。
1. source 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

**RegExp实例方法**  
*exec()*  
exec()接受一个参数，及要应用模式的字符串，然后返回包含第一个匹配项信息的数组;或者在没有匹配项的情况下返回null。  
返回的数组虽然是Array的实例，但额外包含两个属性：index和input：  
* index: 表示匹配项在字符串中的位置。
* input: 表示应用正则表达式的字符串。  

在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中捕获组匹配的字符串：  
```js
var text = "mom and dad and baby";
var pattern = /mom( and dady (and baby)?)?/gi;
var matches = pattern.exec(text);
alert(matches.index); // 0
alert(matches.input); // "mom and dad and baby"
alert(matches[0]); // "mom and dad and baby
alert(matches[1]); // " and dad and baby"
alert(matches[2]); // " and baby"
```
对于exec()而言，即使模式中设置了g，每次也只返回一个匹配项。  
在不设置g时，在同一个字符串多次调用exec(),始终返回地一个匹配信息。  
设置了g， 每次调用都会在字符串中查找新的匹配项。  

*test*  
```js
var text = "000-00-0000";
var pattern = /\d{3}-\d{2}-\d{4}/;
if (pattern.test(text)) {
    alert("The pattern was matched.");
}
```
正则表达式的valueOf()返回正则表达式本身。  

**RegExp构造函数属性**  
相当于静态属性。  

| 长属性名 | 短属性名 | 说明 |
| ------ | ------ | ------ |
| input | $_ | 最近一次要匹配的字符串 |
| lastMatch | $& | 最近一次的匹配项 |
| lastParen | $+ | 最近一次匹配的捕获组 |
| leftContext | $\` | input字符串中lastMatch之前的文本 |
| multiline | $* | 布尔值，表示是否所有的表达式都使用多行模式。 |
| rightContext | $' | Input字符串中lastMatch之后的文本 |

**模式的局限性**  
ECMAScript不支持的正则表达式：  
。。。

### 5. Function类型
**没有重载**  
函数名相当于指针，“重载”会使函数名指向新的函数。  

**函数申明与函数表达式**  
函数声明优先解析。  
函数表达式必须等到解析器解析到其所在行。  

**作为值的函数**  
函数名作参数：  
```js
function callSomeFunction(someFunction, someArgument) {
    return someFunction(someArgument);
}
function add10(num) {
    return num + 10;
}
var result1 = callSomeFunction(add10, 10);
alert(result); // 20
```
函数作为返回值：  
```js
function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        if (value1 < value2) {
            return -1;
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
```

**函数内部属性**  
*arguments*  
```js
// 阶乘
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num-1)
    }
}
```
*this*  
```js
window.color = "red";
var o = {color: "blue"};
function sayColor() {
    alert(this.color);
}
sayColor();
o.sayColor = sayColor;
o.sayColor();
```
*caller*  
这个属性中保存着调用当前函数的函数的引用。  

**函数属性和方法**  
属性：  
1. length: 函数希望接收的`命名参数`的个数。
2. prototype: 保存实例方法。不可枚举，使用for-in无法发现。

非继承的方法：
1. apply():  
   apply()方法接受两个参数：作用域和参数数组。  
   ```
   function sum(num1, num2) {
       return num1 + num2;
   }
   function callSum1(num1, num2) {
       return sum.apply(this, arguments);
   }
   function callSum2(num1, num2) {
       return sum.apply(this, [num1, num2]);
   }
   ```
2. call()  
   与apply（）类似，只是参数不同。  
   ```
   function callSum(num1, num2) {
       return sum.call(this, sum1, sum2);
   }
   ```
3. bind()  
   函数实例与this值绑定：  
   ```
   window.color = "red";
   var o = {color: "blue"};
   function sayColor() {
       alert(this.color);
   }
   var objectSayColor = sayColor.bind(o);
   objectSayColor();
   ```
   
继承的方法： toLocaleString(), toString(), valueOf()。

### 6. 基本包装类型
不建议显式地创建基本包装类型的对象。  

**Boolean类型**  
永远不要使用Boolean对象。  

**Number类型**  
格式化方法：  
1. toFixed()  
   ```
   var num = 10;
   alert(num.toFixed(2)); //"10.00"
   ```
2. toExponential()  
   ```
   num.toExponential(1); // "1.0e+1"
   ```
3. toPrecision()  
   toPrecision()方法可以表现1到21位小数。  
   
**String类型**  
属性：  
length：  即使字符串中包含双字节字符，也算一个字符。  
字符方法：  
1. charAt(), charCodeAt(), \[]:  
   ```
   var stringValue = "hello world";
   alert(stringValue.charAt(1)); //"e"
   alert(stringValue.charCodeAt(1)); //"101"
   alert(stringValue[1]); //"e"
   ```
字符串操作方法：  
1. concat(): 将一个或多个字符串拼接起来。  
   原字符串不变。  
2. slice(), substr(), substring():  
   不会修改字符串本身。  
   
字符串位置方法：  
1. indexOf(), lastIndexOf():  
   lastIndexOf是从后向前搜索。  

trim():  
不修改原字符串。  

字符串大小写转换方法：  
toLowerCase(), toUpperCase()  

字符串的模式匹配方法：  
1. match()  
2. search()  
3. replace()  
4. split()  
   语法： stringObject.split(separator,howmany)  
   如果吧空字符串""作为separator，那么stringObject的每个字符之间都会分割。  
   String.split()执行的操作与Array.join()的操作是相反的。  
   * separator 必须，字符串或正则表达式。  
   * howmany 可选。返回的数组的最大长度。  

localeCompare()方法：  
比较字符串大小。  

fromCharCode():  
String构造函数本身的一个静态方法。`alert(String.fromCharCode(104,101,108,108,111)); // "hello"`  

### 7. 单体内置对象
**Global对象**  
isNaN(), isFinite(), parseInt(), parseFloat()都是Global的方法。  
*(1) URI编码方法*  
encodeURI()和ehcodeURIComponent()  
*(2) eval()方法*  
eval()方法就像一个完整的ECMAScript解析器。  
*(3) Global对象的属性*  
*(4) window对象*  

**Math对象**  
与我们直接编写的计算功能相比，Math对象提供的计算功能执行起来要快很多。  

| 属性 | 说明 |
| ------ | ------ |
| Math.E | e的值 |
| Math.LN10 | ln(10) |
| Math.LN2 | ln(2) |
| Math.LOG2E | log2(e) |
| Math.LOG10E | log(e) |
| Math.PI | 元周率 |
| Math.SQRT1_2 | 1/2的平方根 |
| Math.SQRT2 | 2的平方根 |

*(1) min()和max()*  
*(2) apply()**  
找到数组中的最大值或最小值：  
```
var values = [1, 2, 3, 4, 5];
var max = Math.max.apply(Math, values);
```
*(3) 舍入方法*  
Math.ceil(), Math.floor(), Math.round()  
*(4) random()方法*  
返回介于0到1之间的随机数，不包括0和1.  
*(5) 其他方法*  

| 方法 | 说明 |
| ------ | ------ |
| Math.abs(num) | num的绝对值 |
| Math.exp(num) | 返回Math.E的num次幂 |
| Math.log(num) | 返回num的自然对数 |
| Math.pow(num, power) | 返回num的power次幂 |
| Math.sqrt(num) | 返回num的平方根 |
| Math.acos(x) | 返回x的反余弦值 |
| Math.asin(x) | 返回x的反正弦值 |
| Math.atan(x) | 返回x的反正切值 |
| Math.atan2(y, x) | 返回y/x的反正切值 |
| Math.cos(x) | 返回x的余弦值 |
| Math.sin(x) | 返回x的正弦值 |
| Math.tan(x) | 返回x的正切值 |

